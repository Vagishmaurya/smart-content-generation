<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spherical Mirrors - Physics in Motion</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #667db6 100%);
            color: white;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* Audio Control */
        #audio-control {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .control-btn {
            background: rgba(255, 183, 77, 0.9);
            border: none;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            aria-label: "Toggle audio narration";
        }

        .control-btn:hover {
            transform: scale(1.1);
            background: rgba(255, 183, 77, 1);
        }

        .control-btn:focus {
            outline: 3px solid #fff;
            outline-offset: 2px;
        }

        .control-btn.muted .unmute-icon { display: none; }
        .control-btn:not(.muted) .mute-icon { display: none; }

        /* Main Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 30px 20px;
        }

        /* Hero Section */
        .hero {
            text-align: center;
            margin-bottom: 50px;
            padding: 40px 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 25px;
            backdrop-filter: blur(10px);
        }

        .hero h1 {
            font-size: 3.5rem;
            background: linear-gradient(45deg, #ffb74d, #ff6f00, #e65100);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            font-weight: 700;
        }

        .hero p {
            font-size: 1.3rem;
            opacity: 0.95;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }

        /* Mirror Stage */
        .mirror-stage {
            background: linear-gradient(to right, #2c3e50, #34495e);
            border-radius: 25px;
            min-height: 500px;
            position: relative;
            margin: 40px 0;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
            overflow: hidden;
            border: 3px solid rgba(255, 183, 77, 0.4);
            padding: 20px;
        }

        /* SVG Container for Ray Diagrams */
        .ray-diagram {
            width: 100%;
            height: 400px;
            display: block;
            margin: 20px auto;
        }

        /* Mirror Types Showcase */
        .mirror-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin: 40px 0;
        }

        .mirror-card {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            border: 2px solid rgba(255, 183, 77, 0.3);
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .mirror-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
        }

        .mirror-card h3 {
            color: #ffb74d;
            font-size: 1.8rem;
            margin-bottom: 15px;
        }

        /* Controls */
        .controls {
            text-align: center;
            margin: 40px 0;
        }

        .controls-title {
            font-size: 2rem;
            margin-bottom: 25px;
            color: #ffb74d;
            font-weight: 600;
        }

        .demo-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin: 25px 0;
        }

        .demo-btn {
            background: linear-gradient(135deg, #ffb74d, #ff6f00);
            border: none;
            color: white;
            padding: 16px 28px;
            border-radius: 35px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(255, 183, 77, 0.3);
            min-width: 180px;
        }

        .demo-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 30px rgba(255, 183, 77, 0.4);
        }

        .demo-btn:focus {
            outline: 3px solid #fff;
            outline-offset: 2px;
        }

        .demo-btn:active {
            transform: translateY(-1px);
        }

        .demo-btn.active {
            background: linear-gradient(135deg, #4caf50, #2e7d32);
            box-shadow: 0 8px 25px rgba(76, 175, 80, 0.4);
        }

        /* Calculator Section */
        .calculator-section {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 25px;
            padding: 35px;
            margin: 35px 0;
            border: 3px solid rgba(255, 183, 77, 0.4);
            backdrop-filter: blur(15px);
        }

        .calculator-title {
            font-size: 1.8rem;
            color: #ffb74d;
            margin-bottom: 25px;
            text-align: center;
            font-weight: 600;
        }

        .calculator-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            margin-bottom: 8px;
            color: #ffb74d;
            font-weight: 500;
        }

        .input-group input {
            padding: 12px;
            border-radius: 10px;
            border: 2px solid rgba(255, 183, 77, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #ffb74d;
            background: rgba(255, 255, 255, 0.15);
        }

        .calc-btn {
            background: linear-gradient(135deg, #4caf50, #2e7d32);
            border: none;
            color: white;
            padding: 14px 32px;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 5px;
        }

        .calc-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(76, 175, 80, 0.3);
        }

        .calculator-result {
            text-align: center;
            padding: 20px;
            background: rgba(76, 175, 80, 0.2);
            border-radius: 15px;
            margin-top: 20px;
            font-size: 1.3rem;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Quiz Section */
        .quiz-section {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 25px;
            padding: 35px;
            margin: 35px 0;
            border: 3px solid rgba(255, 183, 77, 0.4);
        }

        .quiz-title {
            font-size: 2rem;
            color: #ffb74d;
            text-align: center;
            margin-bottom: 30px;
        }

        .quiz-question {
            background: rgba(255, 255, 255, 0.05);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            display: none;
        }

        .quiz-question.active {
            display: block;
        }

        .question-text {
            font-size: 1.2rem;
            margin-bottom: 20px;
            color: #fff;
        }

        .quiz-options {
            display: grid;
            gap: 15px;
        }

        .quiz-option {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .quiz-option:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 183, 77, 0.5);
        }

        .quiz-option.correct {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4caf50;
        }

        .quiz-option.incorrect {
            background: rgba(244, 67, 54, 0.3);
            border-color: #f44336;
        }

        .quiz-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .quiz-score {
            text-align: center;
            font-size: 1.5rem;
            color: #4caf50;
            margin-top: 20px;
            padding: 20px;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 15px;
        }

        /* Summary Card */
        .summary-card {
            background: linear-gradient(135deg, rgba(255, 183, 77, 0.2), rgba(255, 111, 0, 0.2));
            border-radius: 25px;
            padding: 40px;
            margin: 40px 0;
            border: 3px solid rgba(255, 183, 77, 0.4);
        }

        .summary-title {
            font-size: 2rem;
            color: #ffb74d;
            text-align: center;
            margin-bottom: 30px;
        }

        .key-points {
            display: grid;
            gap: 20px;
        }

        .key-point {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 15px;
            border-left: 4px solid #ffb74d;
        }

        .key-point h4 {
            color: #ffb74d;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        /* Worked Examples */
        .examples-section {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 25px;
            padding: 35px;
            margin: 35px 0;
            border: 3px solid rgba(255, 183, 77, 0.4);
        }

        .example-title {
            font-size: 1.8rem;
            color: #ffb74d;
            margin-bottom: 25px;
            text-align: center;
        }

        .example-problem {
            background: rgba(255, 255, 255, 0.05);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .problem-statement {
            font-size: 1.1rem;
            margin-bottom: 20px;
            color: #fff;
        }

        .solution-steps {
            padding-left: 20px;
        }

        .solution-step {
            margin: 15px 0;
            padding: 15px;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 10px;
            border-left: 3px solid #4caf50;
        }

        /* Animations */
        @keyframes rayTrace {
            0% { stroke-dashoffset: 500; }
            100% { stroke-dashoffset: 0; }
        }

        @keyframes pulsePoint {
            0%, 100% { r: 5; opacity: 1; }
            50% { r: 8; opacity: 0.7; }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.5rem;
            }
            
            .mirror-stage {
                min-height: 400px;
            }
            
            .demo-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .calculator-inputs {
                grid-template-columns: 1fr;
            }
        }

        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.001s !important;
                transition-duration: 0.001s !important;
            }
        }

        /* Focus Styles for Accessibility */
        button:focus-visible, 
        input:focus-visible, 
        a:focus-visible {
            outline: 3px solid #ffb74d;
            outline-offset: 2px;
        }

        /* Skip to Content Link */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #ffb74d;
            color: #000;
            padding: 8px;
            text-decoration: none;
            z-index: 100;
        }

        .skip-link:focus {
            top: 0;
        }
    </style>
</head>
<body>
    <!-- Skip to Content for Accessibility -->
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <!-- Audio Control -->
    <div id="audio-control">
        <button id="mute-btn" class="control-btn" aria-label="Toggle audio narration">
            <span class="unmute-icon">🔊</span>
            <span class="mute-icon">🔇</span>
        </button>
    </div>

    <div class="container" id="main-content">
        <!-- Hero Section -->
        <header class="hero">
            <h1>Spherical Mirrors</h1>
            <p>Discover the fascinating world of curved mirrors! Learn how concave and convex mirrors bend light, create images, and find applications in our daily lives from telescopes to car mirrors.</p>
        </header>

        <!-- Mirror Types Showcase -->
        <section class="mirror-types" role="region" aria-label="Mirror Types">
            <div class="mirror-card">
                <h3>🔍 Concave Mirror</h3>
                <p>Curves inward like a cave. The reflecting surface is on the concave (inward) side. Converges light rays to a focal point. Used in telescopes, headlights, and shaving mirrors.</p>
            </div>
            <div class="mirror-card">
                <h3>🔮 Convex Mirror</h3>
                <p>Curves outward like a dome. The reflecting surface is on the convex (outward) side. Diverges light rays. Used in car side mirrors, security mirrors, and street corners.</p>
            </div>
        </section>

        <!-- Mirror Stage for Ray Diagrams -->
        <section class="mirror-stage" role="region" aria-label="Interactive Mirror Demonstration">
            <div id="stage-content">
                <svg id="ray-diagram" class="ray-diagram" viewBox="0 0 800 400" aria-label="Ray diagram demonstration">
                    <!-- SVG content will be dynamically generated -->
                </svg>
            </div>
        </section>

        <!-- Controls -->
        <section class="controls" role="region" aria-label="Demo Controls">
            <h2 class="controls-title" id="lesson-title">Explore Mirror Properties</h2>
            
            <div class="demo-buttons" role="group" aria-label="Demonstration buttons">
                <button class="demo-btn" onclick="playStoryMode()" aria-label="Play complete story mode">📖 Story Mode</button>
                <button class="demo-btn" onclick="showConcaveDemo()" aria-label="Show concave mirror demo">🔍 Concave Mirror</button>
                <button class="demo-btn" onclick="showConvexDemo()" aria-label="Show convex mirror demo">🔮 Convex Mirror</button>
                <button class="demo-btn" onclick="showFocalLengthDemo()" aria-label="Show focal length calculation">📏 Focal Length</button>
                <button class="demo-btn" onclick="resetDemo()" aria-label="Reset demonstration">🔄 Reset</button>
            </div>
        </section>

        <!-- Worked Examples -->
        <section class="examples-section" role="region" aria-label="Worked Examples">
            <h2 class="example-title">📚 Worked Examples</h2>
            
            <div class="example-problem">
                <div class="problem-statement">
                    <strong>Problem 1:</strong> A concave mirror has a radius of curvature of 30 cm. Find its focal length.
                </div>
                <div class="solution-steps">
                    <div class="solution-step">
                        <strong>Step 1:</strong> Given: Radius of curvature (R) = 30 cm
                    </div>
                    <div class="solution-step">
                        <strong>Step 2:</strong> Using the relationship: R = 2f
                    </div>
                    <div class="solution-step">
                        <strong>Step 3:</strong> Therefore: f = R/2 = 30/2 = 15 cm
                    </div>
                    <div class="solution-step">
                        <strong>Answer:</strong> The focal length is 15 cm
                    </div>
                </div>
            </div>

            <div class="example-problem">
                <div class="problem-statement">
                    <strong>Problem 2:</strong> A convex mirror has a focal length of -20 cm. What is its radius of curvature?
                </div>
                <div class="solution-steps">
                    <div class="solution-step">
                        <strong>Step 1:</strong> Given: Focal length (f) = -20 cm (negative for convex mirror)
                    </div>
                    <div class="solution-step">
                        <strong>Step 2:</strong> Using the relationship: R = 2f
                    </div>
                    <div class="solution-step">
                        <strong>Step 3:</strong> Therefore: R = 2 × (-20) = -40 cm
                    </div>
                    <div class="solution-step">
                        <strong>Answer:</strong> The radius of curvature is -40 cm
                    </div>
                </div>
            </div>
        </section>

        <!-- Calculator Section -->
        <section class="calculator-section" role="region" aria-label="Mirror Calculator">
            <h2 class="calculator-title">🧮 Mirror Calculator</h2>
            
            <div class="calculator-inputs">
                <div class="input-group">
                    <label for="calc-radius">Radius of Curvature (cm):</label>
                    <input type="number" id="calc-radius" placeholder="Enter radius" aria-label="Enter radius of curvature">
                </div>
                <div class="input-group">
                    <label for="calc-focal">Focal Length (cm):</label>
                    <input type="number" id="calc-focal" placeholder="Enter focal length" aria-label="Enter focal length">
                </div>
            </div>
            
            <div style="text-align: center;">
                <button class="calc-btn" onclick="calculateFromRadius()">Calculate from Radius</button>
                <button class="calc-btn" onclick="calculateFromFocal()">Calculate from Focal Length</button>
                <button class="calc-btn" onclick="clearCalculator()">Clear</button>
            </div>
            
            <div class="calculator-result" id="calc-result" role="status" aria-live="polite">
                Enter a value and click calculate
            </div>
        </section>

        <!-- Quiz Section -->
        <section class="quiz-section" role="region" aria-label="Interactive Quiz">
            <h2 class="quiz-title">🎯 Test Your Knowledge</h2>
            
            <div id="quiz-container">
                <!-- Question 1 -->
                <div class="quiz-question active" data-question="1">
                    <div class="question-text">
                        1. What type of mirror is used in car side mirrors?
                    </div>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false)">Concave mirror</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true)">Convex mirror</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false)">Plane mirror</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false)">Parabolic mirror</div>
                    </div>
                </div>

                <!-- Question 2 -->
                <div class="quiz-question" data-question="2">
                    <div class="question-text">
                        2. If the radius of curvature of a concave mirror is 24 cm, what is its focal length?
                    </div>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false)">24 cm</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true)">12 cm</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false)">48 cm</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false)">6 cm</div>
                    </div>
                </div>

                <!-- Question 3 -->
                <div class="quiz-question" data-question="3">
                    <div class="question-text">
                        3. Which point represents the center of the sphere from which a spherical mirror is cut?
                    </div>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false)">Pole (P)</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true)">Centre of Curvature (C)</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false)">Focus (F)</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false)">Principal axis</div>
                    </div>
                </div>

                <!-- Question 4 -->
                <div class="quiz-question" data-question="4">
                    <div class="question-text">
                        4. A concave mirror can be used to burn paper by focusing sunlight. At which point should the paper be placed?
                    </div>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false)">At the pole</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false)">At the centre of curvature</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true)">At the principal focus</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false)">Between pole and focus</div>
                    </div>
                </div>
            </div>

            <div class="quiz-navigation">
                <button class="calc-btn" onclick="previousQuestion()">Previous</button>
                <button class="calc-btn" onclick="nextQuestion()">Next</button>
                <button class="calc-btn" onclick="resetQuiz()">Reset Quiz</button>
            </div>

            <div class="quiz-score" id="quiz-score" style="display: none;" role="status" aria-live="polite">
                Your Score: <span id="score-display">0/4</span>
            </div>
        </section>

        <!-- Summary Card -->
        <section class="summary-card" role="region" aria-label="Key Takeaways">
            <h2 class="summary-title">🎓 Key Takeaways</h2>
            
            <div class="key-points">
                <div class="key-point">
                    <h4>Mirror Types</h4>
                    <p>Concave mirrors converge light (cave inward) with the reflecting surface on the concave side, while convex mirrors diverge light (bulge outward) with the reflecting surface on the convex side.</p>
                </div>
                <div class="key-point">
                    <h4>Important Terms</h4>
                    <p>Pole (P) - center of mirror surface, Centre of Curvature (C) - center of sphere, Principal Axis - line through P and C.</p>
                </div>
                <div class="key-point">
                    <h4>Focal Length Formula</h4>
                    <p>For all spherical mirrors: R = 2f, where R is radius of curvature and f is focal length.</p>
                </div>
                <div class="key-point">
                    <h4>Applications</h4>
                    <p>Concave: telescopes, headlights, solar furnaces. Convex: security mirrors, vehicle mirrors for wider view.</p>
                </div>
            </div>
        </section>
    </div>

    <script>
        // Voice System
        class MirrorNarrator {
            constructor() {
                this.isEnabled = true;
                this.currentUtterance = null;
                this.settings = { rate: 0.9, pitch: 1.0, volume: 0.85 };
                this.isDestroyed = false;
            }

            async speak(text, delay = 0) {
                if (!this.isEnabled || !text || this.isDestroyed) return;
                
                return new Promise((resolve) => {
                    setTimeout(() => {
                        if (this.isDestroyed) {
                            resolve();
                            return;
                        }
                        this.stop();
                        const utterance = new SpeechSynthesisUtterance(text);
                        Object.assign(utterance, this.settings);
                        
                        utterance.onend = resolve;
                        utterance.onerror = resolve;
                        
                        this.currentUtterance = utterance;
                        speechSynthesis.speak(utterance);
                    }, delay);
                });
            }

            stop() {
                speechSynthesis.cancel();
                this.currentUtterance = null;
            }

            toggle() {
                this.isEnabled = !this.isEnabled;
                if (!this.isEnabled) this.stop();
                return this.isEnabled;
            }
            
            destroy() {
                this.isDestroyed = true;
                this.stop();
                this.currentUtterance = null;
                this.settings = null;
            }
        }

        // Global state management
        let narrator = new MirrorNarrator();
        let isPlaying = false;
        let currentDemoAborted = false;
        let activeAnimations = [];
        let currentRunId = 0;
        let currentQuizQuestion = 1;
        let quizScore = 0;
        let quizAnswered = [false, false, false, false];

        // Initialize
        window.addEventListener('load', () => {
            narrator.speak("Welcome to Spherical Mirrors! Discover how curved mirrors bend light to create amazing effects. Let's explore the physics of reflection!");
            drawInitialDiagram();
        });

        // Draw initial diagram
        function drawInitialDiagram() {
            const svg = document.getElementById('ray-diagram');
            svg.innerHTML = `
                <defs>
                    <marker id="arrowhead" markerWidth="6" markerHeight="4.2" refX="6" refY="2.1" orient="auto">
                        <polygon points="0 0, 6 2.1, 0 4.2" fill="#ffb74d" />
                    </marker>
                </defs>
                <text x="400" y="200" text-anchor="middle" fill="#ffb74d" font-size="24" font-weight="bold">
                  
                </text>
            `;
        }

        // Complete Story Mode
        async function playStoryMode() {
            resetDemo();
            await wait(200);
            
            isPlaying = true;
            currentDemoAborted = false;
            const runId = ++currentRunId;
            setActiveButton(0);
            
            if (!narrator) {
                narrator = new MirrorNarrator();
            }
            
            updateTitle("📖 The Complete Story of Spherical Mirrors");
            
            // Chapter 1: Introduction
            await narrator.speak("Welcome to the complete story of spherical mirrors! We'll explore these fascinating curved mirrors in the same order as our demonstration buttons: first concave mirrors, then convex mirrors, and finally the focal length relationship.");
            if (!shouldContinue()) return;
            
            // Chapter 2: Concave Mirror (following button order)
            await narrator.speak("Chapter 1: Let's start with concave mirrors. These mirrors curve inward like a cave, with the reflecting surface on the concave side.");
            if (!shouldContinue()) return;
            
            await drawConcaveMirror();
            await wait(1000);
            
            await narrator.speak("Notice the important points: P is the pole at the center of the mirror surface, C is the center of curvature, and F is the principal focus.");
            if (!shouldContinue()) return;
            
            await narrator.speak("When parallel light rays hit a concave mirror, they converge at the principal focus. Watch this amazing convergence!");
            if (!shouldContinue()) return;
            
            await animateConcaveRays();
            await wait(2000);
            
            await narrator.speak("This convergence of light at the focus creates a concentration of energy. That's why concave mirrors can focus sunlight to burn paper! The parallel rays of sunlight converge at the focal point, creating intense heat. This principle is used in solar furnaces and telescopes.");
            if (!shouldContinue()) return;
            
            // Chapter 3: Convex Mirror (following button order)
            await narrator.speak("Chapter 2: Now let's explore convex mirrors. These mirrors bulge outward like a dome, with the reflecting surface on the convex side.");
            if (!shouldContinue()) return;
            
            await drawConvexMirror();
            await wait(1000);
            
            await narrator.speak("Convex mirrors have a virtual focus behind the mirror surface. Light rays appear to diverge from this point, creating a wider field of view.");
            if (!shouldContinue()) return;
            
            await animateConvexRays();
            await wait(2000);
            
            await narrator.speak("This diverging property makes convex mirrors perfect for security and vehicle mirrors. Remember: Objects in mirror are closer than they appear! The wider field of view helps drivers see more of their surroundings.");
            if (!shouldContinue()) return;
            
            // Chapter 4: Focal Length Relationship (following button order)
            await narrator.speak("Chapter 3: Finally, let's examine the fundamental relationship between focal length and radius of curvature that applies to all spherical mirrors.");
            if (!shouldContinue()) return;
            
            await drawFocalLengthDiagram();
            await wait(1000);
            
            await narrator.speak("For all spherical mirrors, the radius equals two times the focal length! This is the key formula: R equals 2f. For a mirror with radius 30 centimeters, the focal length is 15 centimeters.");
            if (!shouldContinue()) return;
            
            await narrator.speak("This relationship is crucial for understanding how spherical mirrors work. Whether concave or convex, this mathematical relationship holds true and helps us predict how light will behave when it encounters these curved surfaces.");
            if (!shouldContinue()) return;
            
            // Conclusion
            await narrator.speak("This completes our journey through spherical mirrors! We've explored concave mirrors that converge light, convex mirrors that diverge light, and the fundamental R equals 2f relationship that governs both types. These principles are essential for understanding telescopes, vehicle mirrors, and many other optical devices in our daily lives.");
            
            isPlaying = false;
        }

        // Concave Mirror Demo
        async function showConcaveDemo() {
            resetDemo();
            await wait(200);
            
            isPlaying = true;
            currentDemoAborted = false;
            setActiveButton(1);
            
            if (!narrator) {
                narrator = new MirrorNarrator();
            }
            
            updateTitle("🔍 Concave Mirror Demonstration");
            
            await narrator.speak("Let's explore the concave mirror! Watch how it converges parallel light rays to a focal point.");
            if (!shouldContinue()) return;
            
            await drawConcaveMirror();
            await wait(1000);
            
            await narrator.speak("The pole P is at the center of the mirror surface. The center of curvature C is the center of the imaginary sphere.");
            if (!shouldContinue()) return;
            
            await animateConcaveRays();
            
            await narrator.speak("Notice how all parallel rays converge at the focus F. The focal length is exactly half the radius of curvature!");
            if (!shouldContinue()) return;
            
            await narrator.speak("This convergence of rays at the focus creates a concentration of energy. That's why concave mirrors can focus sunlight to create intense heat - enough to burn paper! This principle is used in solar furnaces and telescopes.");
            
            isPlaying = false;
        }

        // Convex Mirror Demo
        async function showConvexDemo() {
            resetDemo();
            await wait(200);
            
            isPlaying = true;
            currentDemoAborted = false;
            setActiveButton(2);
            
            if (!narrator) {
                narrator = new MirrorNarrator();
            }
            
            updateTitle("🔮 Convex Mirror Demonstration");
            
            await narrator.speak("Now let's see the convex mirror! It diverges light rays, creating a wider field of view.");
            if (!shouldContinue()) return;
            
            await drawConvexMirror();
            await wait(1000);
            
            await narrator.speak("The convex mirror has a virtual focus behind the mirror surface. Light rays appear to diverge from this point.");
            if (!shouldContinue()) return;
            
            await animateConvexRays();
            
            await narrator.speak("This diverging property makes convex mirrors perfect for security and vehicle mirrors, providing a panoramic view!");
            
            isPlaying = false;
        }

        // Focal Length Demo
        async function showFocalLengthDemo() {
            resetDemo();
            await wait(200);
            
            isPlaying = true;
            currentDemoAborted = false;
            setActiveButton(3);
            
            if (!narrator) {
                narrator = new MirrorNarrator();
            }
            
            updateTitle("📏 Focal Length Relationship");
            
            await narrator.speak("Let's visualize the fundamental relationship: Radius equals two times focal length!");
            if (!shouldContinue()) return;
            
            await drawFocalLengthDiagram();
            
            await narrator.speak("For a mirror with radius 30 centimeters, the focal length is 15 centimeters. This R equals 2f relationship applies to all spherical mirrors!");
            
            isPlaying = false;
        }

        // Drawing functions
        async function drawConcaveMirror() {
            const svg = document.getElementById('ray-diagram');
            svg.innerHTML = `
                <defs>
                    <marker id="arrowhead" markerWidth="6" markerHeight="4.2" refX="6" refY="2.1" orient="auto">
                        <polygon points="0 0, 6 2.1, 0 4.2" fill="#ffb74d" />
                    </marker>
                </defs>
                <!-- Mirror curve -->
                <path d="M 600 100 Q 700 200 600 300" stroke="#ffb74d" stroke-width="3" fill="none"/>
                
                <!-- Reflecting surface indicator (left/concave side) -->
                <path d="M 605 135 L 620 135" stroke="#ff6f00" stroke-width="2"/>
                <text x="490" y="140" fill="#ff6f00" font-size="14">Reflecting surface</text>
                
                <!-- Non-reflecting surface indicator (right/convex side) -->
                <path d="M 680 250 L 695 250" stroke="#888" stroke-width="2"/>
                <text x="700" y="253" fill="#888" font-size="14">Non-reflecting surface</text>
                
                <!-- Principal axis -->
                <line x1="200" y1="200" x2="700" y2="200" stroke="#fff" stroke-width="2" stroke-dasharray="5,5" opacity="0.5"/>
                
                <!-- Points -->
                <circle cx="650" cy="200" r="5" fill="#ff6f00" id="pole"/> <!-- Pole P -->
                <circle cx="450" cy="200" r="5" fill="#4caf50" id="center"/> <!-- Center C -->
                <circle cx="550" cy="200" r="5" fill="#2196f3" id="focus"/> <!-- Focus F -->
                
                <!-- Labels -->
                <text x="650" y="230" fill="#ff6f00" font-size="18" font-weight="bold">P</text>
                <text x="450" y="230" fill="#4caf50" font-size="18" font-weight="bold">C</text>
                <text x="550" y="230" fill="#2196f3" font-size="18" font-weight="bold">F</text>
                
                <!-- Title -->
                <text x="350" y="50" text-anchor="middle" fill="#ffb74d" font-size="22" font-weight="bold">Concave Mirror</text>
            `;
        }

        async function drawConvexMirror() {
            const svg = document.getElementById('ray-diagram');
            svg.innerHTML = `
                <defs>
                    <marker id="arrowhead" markerWidth="6" markerHeight="4.2" refX="6" refY="2.1" orient="auto">
                        <polygon points="0 0, 6 2.1, 0 4.2" fill="#ffb74d" />
                    </marker>
                    <marker id="arrowhead-left" markerWidth="6" markerHeight="4.2" refX="0" refY="2.1" orient="auto">
                        <polygon points="6 0, 0 2.1, 6 4.2" fill="#ffb74d" />
                    </marker>
                </defs>
                <!-- Mirror curve -->
                <path d="M 550 100 Q 450 200 550 300" stroke="#ffb74d" stroke-width="3" fill="none"/>
                <text x="550" y="95" fill="#ffb74d" font-size="16">M</text>
                <text x="550" y="310" fill="#ffb74d" font-size="16">N</text>
                
                <!-- Reflecting surface indicator (right/cave side) -->
                <path d="M 500 135 L 515 135" stroke="#ff6f00" stroke-width="2"/>
                <text x="385" y="140" fill="#ff6f00" font-size="14">Reflecting surface</text>
                
                <!-- Non-reflecting surface indicator (left side) -->
                <path d="M 555 250 L 570 250" stroke="#888" stroke-width="2"/>
                <text x="575" y="253" fill="#888" font-size="14">Non-reflecting surface</text>
                
                <!-- Principal axis -->
                <line x1="200" y1="200" x2="900" y2="200" stroke="#fff" stroke-width="2" stroke-dasharray="5,5" opacity="0.5"/>
                
                <!-- Object at infinity label -->
                <line x1="200" y1="120" x2="200" y2="280" stroke="#4c7cff" stroke-width="2"/>
                <text x="200" y="110" fill="#4c7cff" font-size="16" text-anchor="middle">A</text>
                <text x="200" y="295" fill="#4c7cff" font-size="16" text-anchor="middle">B</text>
                <text x="150" y="250" fill="#4c7cff" font-size="14">At</text>
                <text x="150" y="270" fill="#4c7cff" font-size="14">infinity</text>
                
                <!-- Points - all on the right of mirror -->
                <circle cx="550" cy="200" r="5" fill="#ff6f00"/> <!-- Pole P at center of mirror -->
                <circle cx="850" cy="200" r="5" fill="#4caf50"/> <!-- Center C (virtual) -->
                <circle cx="700" cy="200" r="5" fill="#2196f3"/> <!-- Focus F (virtual) -->
                
                <!-- Labels -->
                <text x="550" y="230" fill="#ff6f00" font-size="18" font-weight="bold">P</text>
                <text x="850" y="230" fill="#4caf50" font-size="18" font-weight="bold">C</text>
                <text x="700" y="230" fill="#2196f3" font-size="18" font-weight="bold">F</text>
                
                <!-- Title -->
                <text x="450" y="50" text-anchor="middle" fill="#ffb74d" font-size="22" font-weight="bold">Convex Mirror</text>
            `;
        }

        async function drawFocalLengthDiagram() {
            const svg = document.getElementById('ray-diagram');
            svg.innerHTML = `
                <defs>
                    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="8" refY="2.8" orient="auto">
                        <polygon points="0 0, 8 2.8, 0 5.6" fill="#ffb74d" />
                    </marker>
                </defs>
                <!-- Mirror -->
                <path d="M 600 100 Q 700 200 600 300" stroke="#ffb74d" stroke-width="3" fill="none"/>
                
                <!-- Reflecting surface indicator -->
                <path d="M 605 142 L 620 142" stroke="#ff6f00" stroke-width="2"/>
                <text x="490" y="145" fill="#ff6f00" font-size="14">Reflecting surface</text>
                
                <!-- Principal axis -->
                <line x1="200" y1="200" x2="700" y2="200" stroke="#fff" stroke-width="2"/>
                
                <!-- Points -->
                <circle cx="650" cy="200" r="6" fill="#ff6f00"/> <!-- P -->
                <circle cx="350" cy="200" r="6" fill="#4caf50"/> <!-- C -->
                <circle cx="500" cy="200" r="6" fill="#2196f3"/> <!-- F -->
                
                <!-- Measurements -->
                <line x1="350" y1="180" x2="650" y2="180" stroke="#4caf50" stroke-width="2" marker-end="url(#arrowhead)"/>
                <text x="500" y="170" fill="#4caf50" font-size="16" text-anchor="middle">R = 30 cm</text>
                
                <line x1="500" y1="220" x2="650" y2="220" stroke="#2196f3" stroke-width="2" marker-end="url(#arrowhead)"/>
                <text x="575" y="240" fill="#2196f3" font-size="16" text-anchor="middle">f = 15 cm</text>
                
                <!-- Labels -->
                <text x="650" y="255" fill="#ff6f00" font-size="18" font-weight="bold">P</text>
                <text x="350" y="255" fill="#4caf50" font-size="18" font-weight="bold">C</text>
                <text x="500" y="255" fill="#2196f3" font-size="18" font-weight="bold">F</text>
                
                <!-- Formula -->
                <text x="400" y="80" text-anchor="middle" fill="#ffb74d" font-size="28" font-weight="bold">R = 2f</text>
            `;
        }

        // Removed separate burning paper demo - now explained through narration in concave mirror section

        // Animation functions
        async function animateConcaveRays() {
            const svg = document.getElementById('ray-diagram');
            const existingContent = svg.innerHTML;
            
            const rays = [
                { y: 120, id: 'ray1', delay: 0 },
                { y: 160, id: 'ray2', delay: 0.1 },
                { y: 200, id: 'ray3', delay: 0.2 },
                { y: 240, id: 'ray4', delay: 0.15 },
                { y: 280, id: 'ray5', delay: 0.05 }
            ];
            
            let rayPaths = '';
            rays.forEach((ray, i) => {
                // Different x2 values for each ray: ray1=618, ray2=630, ray3=650, ray4=630, ray5=618
                const x2Values = [618, 641, 650, 641, 618];
                const incidentEndX = x2Values[i];
                rayPaths += `
                    <line x1="200" y1="${ray.y}" x2="${incidentEndX}" y2="${ray.y}" 
                          stroke="#ffd700" stroke-width="2" opacity="0" id="${ray.id}" class="incident-ray">
                    </line>
                    <polygon points="${425-5},${ray.y-5} ${425+5},${ray.y} ${425-5},${ray.y+5}" 
                          fill="#ffd700" opacity="0" id="${ray.id}-arrow" class="incident-arrow">
                    </polygon>
                    ${(() => { const mx = (incidentEndX + 550) / 2; const my = (ray.y + 200) / 2; return `<path d="M ${incidentEndX} ${ray.y} L ${mx} ${my} L 550 200" stroke="#ffd700" stroke-width="2" fill="none" opacity="0" id="${ray.id}-reflected" class="reflected-ray" marker-mid="url(#arrowhead)"></path>` })()}
                    
                `;
            });
            
            svg.innerHTML = existingContent + rayPaths;
            
            // Enhanced GSAP animations
            rays.forEach(ray => {
                // Animate incident rays with a drawing effect
                gsap.fromTo(`#${ray.id}`, 
                    { strokeDasharray: 650, strokeDashoffset: 650, opacity: 0.8 },
                    { strokeDashoffset: 0, duration: 0.7, delay: ray.delay, ease: "power1.inOut" }
                );
                
                // Animate incident arrow
                gsap.fromTo(`#${ray.id}-arrow`, 
                    { opacity: 0, scale: 0 },
                    { opacity: 0.8, scale: 1, duration: 0.3, delay: 0.3 + ray.delay, ease: "back.out" }
                );
                
                // Animate reflected rays: draw first with opacity 0, then fade in arrowhead after
                gsap.fromTo(`#${ray.id}-reflected`, 
                    { strokeDasharray: 200, strokeDashoffset: 200, opacity: 0 },
                    { strokeDashoffset: 0, opacity: 0, duration: 0.5, delay: 0.7 + ray.delay, ease: "power1.inOut" }
                );
                gsap.to(`#${ray.id}-reflected`, {
                    opacity: 0.8,
                    duration: 0.2,
                    delay: 0.7 + ray.delay + 0.5,
                    ease: "power1.out"
                });
                
                
            });
            
            // Add subtle pulsing effect to the focus point
            const focus = document.getElementById('focus');
            if (focus) {
                gsap.to(focus, {
                    r: 7,
                    opacity: 0.9,
                    duration: 0.8,
                    repeat: -1,
                    yoyo: true,
                    ease: "sine.inOut"
                });
            }
        }

        async function animateConvexRays() {
            const svg = document.getElementById('ray-diagram');
            const existingContent = svg.innerHTML;
            
            const rays = [
                { y: 120, divergeY: 50, virtualY: 240, id: 'convex-ray1', delay: 0 },
                { y: 160, divergeY: 120, virtualY: 220, id: 'convex-ray2', delay: 0.12 },
                { y: 200, divergeY: 200, virtualY: 200, id: 'convex-ray3', delay: 0.24 },
                { y: 240, divergeY: 280, virtualY: 180, id: 'convex-ray4', delay: 0.17 },
                { y: 280, divergeY: 350, virtualY: 160, id: 'convex-ray5', delay: 0.05 }
            ];
            
            let rayPaths = '';
            rays.forEach((ray, i) => {
                const incidentX2 = [532, 508, 500, 508, 532][i];
                rayPaths += `
                    <!-- Parallel incident rays from left side -->
                    <line x1="200" y1="${ray.y}" x2="${incidentX2}" y2="${ray.y}" 
                          stroke="#ffd700" stroke-width="2" opacity="0" id="${ray.id}">
                    </line>
                    <polygon points="${375-5},${ray.y-5} ${375+5},${ray.y} ${375-5},${ray.y+5}" 
                          fill="#ffd700" opacity="0" id="${ray.id}-arrow">
                    </polygon>
                    <!-- Diverging reflected rays going back toward left -->
                    <line x1="${incidentX2}" y1="${ray.y}" x2="300" y2="${ray.divergeY}" 
                          stroke="#ffd700" stroke-width="2" opacity="0" id="${ray.id}-reflected">
                    </line>
                    <polygon points="${((incidentX2+300)/2)+6},${((ray.y+ray.divergeY)/2)} ${((incidentX2+300)/2)-3},${((ray.y+ray.divergeY)/2)-4} ${((incidentX2+300)/2)-3},${((ray.y+ray.divergeY)/2)+4}" 
                          fill="#ffd700" opacity="0" id="${ray.id}-reflected-arrow"
                          transform="rotate(${Math.atan2((ray.divergeY - ray.y), (300 - incidentX2)) * 180 / Math.PI} ${((incidentX2+300)/2)} ${((ray.y+ray.divergeY)/2)})"></polygon>
                    <!-- Virtual rays - extending reflected rays behind mirror to meet at focus F -->
                    <line x1="${incidentX2}" y1="${ray.y}" x2="700" y2="200" 
                          stroke="#ffd700" stroke-width="1" stroke-dasharray="5,5" opacity="0" id="${ray.id}-virtual">
                    </line>
                    <polygon points="${((incidentX2+700)/2)+5},${((ray.y+200)/2)-5} ${((incidentX2+700)/2)-5},${(ray.y+200)/2} ${((incidentX2+700)/2)+5},${((ray.y+200)/2)+5}" 
                          fill="#ffd700" opacity="0" id="${ray.id}-virtual-arrow" 
                          transform="rotate(${Math.atan2((200 - ray.y), (700 - incidentX2)) * 180 / Math.PI} ${((incidentX2+700)/2)} ${( (ray.y+200)/2)})">
                    </polygon>
                `;
            });
            
            svg.innerHTML = existingContent + rayPaths;
            
            // Enhanced GSAP animations
            rays.forEach(ray => {
                // Animate incident rays with a drawing effect (left to right)
                gsap.fromTo(`#${ray.id}`, 
                    { strokeDasharray: 500, strokeDashoffset: 500, opacity: 0.8 },
                    { strokeDashoffset: 0, duration: 0.7, delay: ray.delay, ease: "power1.inOut" }
                );
                
                // Animate incident arrow
                gsap.fromTo(`#${ray.id}-arrow`, 
                    { opacity: 0, scale: 0 },
                    { opacity: 0.8, scale: 1, duration: 0.3, delay: 0.3 + ray.delay, ease: "back.out" }
                );
                
                // Animate reflected rays (going back toward left)
                gsap.fromTo(`#${ray.id}-reflected`, 
                    { strokeDasharray: 350, strokeDashoffset: 350, opacity: 0 },
                    { strokeDashoffset: 0, opacity: 0.8, duration: 0.5, delay: 0.7 + ray.delay, ease: "power1.inOut" }
                );
                
                // Animate reflected arrow with slight bounce
                gsap.fromTo(`#${ray.id}-reflected-arrow`, 
                    { opacity: 0, scale: 0 },
                    { opacity: 0.8, scale: 1, duration: 0.3, delay: 0.9 + ray.delay, ease: "back.out(2)" }
                );
                
                // Animate virtual rays with dashed line drawing effect
                gsap.fromTo(`#${ray.id}-virtual`, 
                    { strokeDasharray: 80, strokeDashoffset: 80, opacity: 0 },
                    { strokeDashoffset: 0, opacity: 0.4, duration: 0.6, delay: 1.2 + ray.delay, ease: "power1.inOut" }
                );
                
                // Animate virtual arrow
                gsap.fromTo(`#${ray.id}-virtual-arrow`, 
                    { opacity: 0, scale: 0 },
                    { opacity: 0.4, scale: 1, duration: 0.3, delay: 1.5 + ray.delay, ease: "back.out" }
                );
            });
            
            // Add subtle effect to the virtual focus point
            const focus = document.querySelector('#ray-diagram circle:nth-of-type(3)');
            if (focus) {
                gsap.to(focus, {
                    r: 6,
                    opacity: 0.7,
                    duration: 1,
                    repeat: -1,
                    yoyo: true,
                    ease: "sine.inOut"
                });
            }
        }

        // Calculator functions
        function calculateFromRadius() {
            const radius = parseFloat(document.getElementById('calc-radius').value);
            if (isNaN(radius)) {
                document.getElementById('calc-result').textContent = 'Please enter a valid radius';
                return;
            }
            
            const focal = radius / 2;
            document.getElementById('calc-focal').value = focal;
            document.getElementById('calc-result').textContent = 
                `For R = ${radius} cm, focal length f = ${focal} cm`;
        }

        function calculateFromFocal() {
            const focal = parseFloat(document.getElementById('calc-focal').value);
            if (isNaN(focal)) {
                document.getElementById('calc-result').textContent = 'Please enter a valid focal length';
                return;
            }
            
            const radius = focal * 2;
            document.getElementById('calc-radius').value = radius;
            document.getElementById('calc-result').textContent = 
                `For f = ${focal} cm, radius R = ${radius} cm`;
        }

        function clearCalculator() {
            document.getElementById('calc-radius').value = '';
            document.getElementById('calc-focal').value = '';
            document.getElementById('calc-result').textContent = 'Enter a value and click calculate';
        }

        // Quiz functions
        function checkAnswer(element, isCorrect) {
            const questionDiv = element.parentElement.parentElement;
            const questionNum = parseInt(questionDiv.dataset.question);
            
            if (quizAnswered[questionNum - 1]) return;
            
            quizAnswered[questionNum - 1] = true;
            
            if (isCorrect) {
                element.classList.add('correct');
                quizScore++;
            } else {
                element.classList.add('incorrect');
                // Show correct answer
                const options = element.parentElement.children;
                for (let option of options) {
                    if (option.onclick && option.onclick.toString().includes('true')) {
                        option.classList.add('correct');
                    }
                }
            }
            
            updateQuizScore();
        }

        function nextQuestion() {
            const questions = document.querySelectorAll('.quiz-question');
            if (currentQuizQuestion < questions.length) {
                questions[currentQuizQuestion - 1].classList.remove('active');
                currentQuizQuestion++;
                questions[currentQuizQuestion - 1].classList.add('active');
            }
        }

        function previousQuestion() {
            const questions = document.querySelectorAll('.quiz-question');
            if (currentQuizQuestion > 1) {
                questions[currentQuizQuestion - 1].classList.remove('active');
                currentQuizQuestion--;
                questions[currentQuizQuestion - 1].classList.add('active');
            }
        }

        function resetQuiz() {
            quizScore = 0;
            quizAnswered = [false, false, false, false];
            currentQuizQuestion = 1;
            
            const questions = document.querySelectorAll('.quiz-question');
            questions.forEach((q, index) => {
                q.classList.toggle('active', index === 0);
                const options = q.querySelectorAll('.quiz-option');
                options.forEach(option => {
                    option.classList.remove('correct', 'incorrect');
                });
            });
            
            document.getElementById('quiz-score').style.display = 'none';
        }

        function updateQuizScore() {
            const allAnswered = quizAnswered.every(a => a);
            if (allAnswered) {
                document.getElementById('quiz-score').style.display = 'block';
                document.getElementById('score-display').textContent = `${quizScore}/4`;
            }
        }

        // Helper functions
        function resetDemo() {
            currentDemoAborted = true;
            currentRunId++;
            
            if (narrator) {
                narrator.stop();
                narrator.destroy();
                narrator = null;
                
                setTimeout(() => {
                    narrator = new MirrorNarrator();
                }, 100);
            }
            
            // Kill any active GSAP animations
            gsap.killTweensOf("#ray-diagram *");
            
            activeAnimations.forEach(anim => {
                if (anim && anim.cancel) {
                    anim.cancel();
                }
            });
            activeAnimations = [];
            
            // Fade out current content
            const stage = document.querySelector('.mirror-stage');
            gsap.to(stage, {
                opacity: 0.3,
                duration: 0.3,
                onComplete: () => {
                    drawInitialDiagram();
                    // Fade in new content
                    gsap.to(stage, {
                        opacity: 1, 
                        duration: 0.4,
                        ease: "power2.inOut"
                    });
                }
            });
            
            // Smooth title transition
            const titleElement = document.getElementById('lesson-title');
            gsap.to(titleElement, {
                opacity: 0,
                y: -10,
                duration: 0.3,
                onComplete: () => {
                    updateTitle("Explore Mirror Properties");
                    gsap.to(titleElement, {
                        opacity: 1,
                        y: 0,
                        duration: 0.4,
                        ease: "back.out"
                    });
                }
            });
            
            isPlaying = false;
            speechSynthesis.cancel();
        }

        function shouldContinue() {
            return !currentDemoAborted;
        }

        function updateTitle(title) {
            document.getElementById('lesson-title').textContent = title;
        }

        function setActiveButton(index) {
            document.querySelectorAll('.demo-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === index);
            });
        }

        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Audio Control
        document.getElementById('mute-btn').addEventListener('click', () => {
            speechSynthesis.cancel();
            
            if (narrator) {
                narrator.stop();
                narrator.destroy();
                narrator = new MirrorNarrator();
            }
            
            const isEnabled = narrator.toggle();
            document.getElementById('mute-btn').classList.toggle('muted', !isEnabled);
            document.getElementById('mute-btn').setAttribute('aria-pressed', !isEnabled);
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                resetDemo();
            }
        });
    </script>
</body>
</html>